{
  "Topic": "Controlador de Interrupciones e ISR",
  "questions": [
    {
      "id": 1,
      "question": "¿Qué es la PIC (Programmable Interrupt Controller)?",
      "options": [
        { "option": "a", "text": "Un chip de hardware", "correct": true, "explanation": null },
        { "option": "b", "text": "Un módulo del kernel", "correct": false, "explanation": "La PIC es hardware, no software." },
        { "option": "c", "text": "Una rutina de servicio a interrupciones", "correct": false, "explanation": "Incorrecto" }        
      ]
    },
    {
      "id": 2,
      "question": "Cuando la PIC identifica una interrupción, ¿identifica la fuente y carga la rutina correspondiente en memoria?",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": false, "explanation": "La PIC notifica a la CPU mediante el bus y le pasa el número IRQ, no carga la rutina." },
        { "option": "b", "text": "Falso", "correct": true, "explanation": null }
      ]
    },
    {
      "id": 3,
      "question": "¿Qué significa IRQ (Interrupt Request)?",
      "options": [
        { "option": "a", "text": "Una instrucción privilegiada para enmascarar interrupciones", "correct": false, "explanation": "IRQ es un identificador de línea, no una instrucción." },
        { "option": "b", "text": "Número identificativo de la línea de interrupción asociada a cada dispositivo", "correct": true, "explanation": null },
        { "option": "c", "text": "Un registro en la CPU que almacena el estado de interrupciones pendientes", "correct": false, "explanation": "Eso correspondería más a un flag o máscara, no al IRQ." },
        { "option": "d", "text": "Un modo especial de la CPU para atender múltiples interrupciones simultáneas", "correct": false, "explanation": "El IRQ es simplemente un número, no un modo de funcionamiento." }
      ]
    },
    {
      "id": 4,
      "question": "CLI y STI son…",
      "options": [
        { "option": "a", "text": "Instrucciones privilegiadas para enmascarar interrupciones a nivel de CPU", "correct": true, "explanation": null },
        { "option": "b", "text": "Instrucciones capaces de modificar el registro de estado (IF en EFLAGS)", "correct": true, "explanation": null },
        { "option": "c", "text": "Instrucciones de usuario para limpiar registros", "correct": false, "explanation": "CLI/STI son privilegios de CPU." },
        { "option": "d", "text": "Instrucciones que gestionan el vector de interrupciones en memoria", "correct": false, "explanation": "Esa función la hace el hardware con la tabla de vectores, no CLI/STI." }
      ]
    },
    {
      "id": 5,
      "question": "Enmascarar una interrupción significa…",
      "options": [
        { "option": "a", "text": "Bloquear temporalmente una línea de IRQ para que la CPU no la atienda", "correct": true, "explanation": null },
        { "option": "b", "text": "Encolar la señal en un buffer FIFO", "correct": false, "explanation": "Mientras está enmascarada, la señal se ignora." },
        { "option": "c", "text": "Deshabilitar los registros de interrupción en la PSW", "correct": false, "explanation": "Decir que “enmascarar” equivale a “deshabilitar registros en la PSW” es incorrecto porque estamos hablando de la máscara de IRQ en el controlador externo, no de la modificación del flag IF en la PSW (aunque ambos mecanismos sirvan para impedir interrupciones, actúan en capas diferentes)." }
      ]
    },
    {
      "id": 5,
      "question": "Enmascarar una interrupción significa…",
      "options": [
        { "option": "a", "text": "Bloquear temporalmente una línea de IRQ para que la CPU no la atienda", "correct": true, "explanation": null },
        { "option": "b", "text": "Encolar la señal en un buffer FIFO", "correct": false, "explanation": "Mientras está enmascarada, la señal se ignora, no se encola." },
        { "option": "c", "text": "Reprogramar la PIC para cambiar la prioridad de esa IRQ", "correct": false, "explanation": "La prioridad se configura aparte; enmascarar solo la bloquea." },
        { "option": "d", "text": "Deshabilitar los registros de interrupción en la PSW", "correct": false, "explanation": "Es confuso con el bit IF, pero enmascarar en PIC no modifica PSW directamente." }
      ]
    },
    {
      "id": 6,
      "question": "¿Existen interrupciones no enmascarables (NMI)?",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": true, "explanation": "Las NMI atienden errores críticos de hardware (como las producidas por el sensor de temperatura de la CPU) y no pueden deshabilitarse." },
        { "option": "b", "text": "Falso", "correct": false, "explanation": null }
      ]
    },
    {
      "id": 7,
      "question": "¿Para qué se utiliza el enmascaramiento de interrupciones?",
      "options": [
        { "option": "a", "text": "Permitir que la CPU termine la instrucción en ejecución antes de atender la ISR", "correct": true, "explanation": null },
        { "option": "b", "text": "Impedir que cualquier IRQ interrumpa secciones críticas del kernel", "correct": true, "explanation": null },
        { "option": "c", "text": "Encolar las solicitudes de interrupción en el sistema operativo", "correct": false, "explanation": "No se encolan, se bloquean hasta deshabilitar el enmascaramiento." },
        { "option": "d", "text": "Forzar el reordenamiento de la tabla de vectores de interrupción", "correct": false, "explanation": "No altera vectores, solo bloquea líneas IRQ." }
      ]
    },  
    {
      "id": 8,
      "question": "¿Qué es una ISR (Interrupt Service Routine)?",
      "options": [
        { "option": "a", "text": "Un fragmento de código privilegiado del SO que atiende una interrupción y luego devuelve el control", "correct": true, "explanation": null },
        { "option": "b", "text": "Un proceso de usuario que gestiona eventos de E/S", "correct": false, "explanation": "Las ISR se ejecutan en modo kernel, no en usuario." },
        { "option": "c", "text": "Un buffer donde se almacenan solicitudes de interrupción", "correct": false, "explanation": "La ISR es código, no un buffer." },
        { "option": "d", "text": "Un hilo del kernel que se programa para atender interrupciones", "correct": false, "explanation": "No es un hilo programable; se invoca directamente en contexto de interrupción." }
      ]
    },
    {
      "id": 9,
      "question": "¿La CPU interrumpe la instrucción en curso para atender una interrupción a mitad de ejecución?",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": false, "explanation": "La CPU completa la instrucción antes de saltar a la ISR." },
        { "option": "b", "text": "Falso", "correct": true, "explanation": null }
      ]
    },
    {
      "id": 10,
      "question": "Al atender una interrupción, la CPU guarda en la pila…",
      "options": [
        { "option": "a", "text": "El PC original (dirección de retorno)", "correct": true, "explanation": null },
        { "option": "b", "text": "La PSW u otros registros necesarios", "correct": true, "explanation": null },
        { "option": "c", "text": "Solo registros de usuario", "correct": false, "explanation": "Se guardan PC y PSW completos, no solo registros de usuario." },
        { "option": "d", "text": "El contenido de la pila del proceso interrumpido", "correct": false, "explanation": "La ISR guarda contexto, no toda la pila del proceso." }
      ]
    },
    {
      "id": 11,
      "question": "¿Qué hace la instrucción IRET al final de una ISR?",
      "options": [
        { "option": "a", "text": "Restaura el PC original y la PSW para retomar la ejecución previa", "correct": true,  "explanation": null },
        { "option": "b", "text": "Enmascara todas las interrupciones antes de retornar", "correct": false, "explanation": "IRET restaura contexto, no modifica máscara." },
        { "option": "c", "text": "Desenmascara todas las interrupciones antes de retornar", "correct": false, "explanation": "IRET restaura contexto, no modifica máscara." },
        { "option": "d", "text": "Carga y actualiza el registro de vectores de interrupción", "correct": false, "explanation": "La tabla de vectores ya estaba cargada; IRET solo restaura contexto." },
        { "option": "e", "text": "Restaura los registros generales guardados al entrar al ISR", "correct": false, "explanation": "Sólo restaura PC y PSW; la restauración de otros registros depende de la rutina de contexto." }
      ]
    },
    {
      "id": 12,
      "question": "¿Cuántas ISR existen bajo el método vectorizado de interrupciones?",
      "options": [
        { "option": "a", "text": "Una sola", "correct": false, "explanation": "Cada IRQ tiene su propia ISR en la tabla." },
        { "option": "b", "text": "Múltiples, una por cada IRQ", "correct": true, "explanation": null }
      ]
    },
    {
      "id": 13,
      "question": "En la tabla vectorizada, las entradas reservan…",
      "options": [
        { "option": "a", "text": "Código máquina completo de cada ISR", "correct": false, "explanation": "Solo se almacenan direcciones de inicio." },
        { "option": "b", "text": "Direcciones de memoria de inicio de cada ISR", "correct": true,  "explanation": null },
        { "option": "c", "text": "Metadatos de prioridad de cada IRQ", "correct": false, "explanation": "La prioridad se gestiona en la PIC/APIC, no en el vector." },
        { "option": "d", "text": "Checksum de integridad de cada ISR", "correct": false, "explanation": "No se almacenan checksums en la tabla de vectores." }
      ]
    },
    {
      "id": 14,
      "question": "Cada IRQ tiene un número único que el hardware pasa a la CPU. ¿Es esto correcto?",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": true, "explanation": null },
        { "option": "b", "text": "Falso", "correct": false, "explanation": "Cada IRQ tiene un numero identificatorio que le indica a la CPU que IRS le corresponde"}
      ]
    },
    {
      "id": 15,
      "question": "Para calcular el índice en el vector de ISR, la CPU…",
      "options": [
        { "option": "a", "text": "Usa el número IRQ directamente como índice", "correct": false, "explanation": "Debe multiplicarlo por el tamaño de cada entrada." },
        { "option": "b", "text": "Multiplica el número IRQ por el tamaño de la palabra (ej. 4 bytes)", "correct": true,  "explanation": null },
        { "option": "c", "text": "Suma el IRQ al puntero base del vector", "correct": false, "explanation": "La suma de bytes se realiza tras la multiplicación, no solo con el IRQ." },
        { "option": "d", "text": "Divide el número IRQ por el tamaño de la palabra", "correct": false, "explanation": "No se divide, se multiplica." }
      ]
    },
    {
      "id": 16,
      "question": "Tras calcular el índice, la CPU…",
      "options": [
        { "option": "a", "text": "Lee desde memoria la dirección de la ISR en ese slot", "correct": true,  "explanation": null },
        { "option": "b", "text": "Salta incondicionalmente a la dirección leída", "correct": true,  "explanation": null },
        { "option": "c", "text": "Vuelve al proceso interrumpido sin ejecutar la ISR", "correct": false, "explanation": "Ejecuta la ISR antes de retornar." },
        { "option": "d", "text": "Actualiza el Program Counter antes de leer el vector", "correct": false, "explanation": "El PC se actualiza al hacer el salto, no antes de leer la dirección." },
        { "option": "e", "text": "Carga la dirección en un registro temporal antes de saltar", "correct": false, "explanation": "Aunque internamente use registros, el paso clave es el salto tras la lectura." }
      ]
    },
    {
      "id": 17,
      "question": "¿La instrucción de retorno es la última en ejecutar dentro de una ISR?",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": true, "explanation": null },
        { "option": "b", "text": "Falso", "correct": false, "explanation": "Incorrecto" }
      ]
    },
    {
      "id": 18,
      "question": "La PIC… (seleccione todas las correctas)",
      "options": [
        { "option": "a", "text": "Es un chip de hardware", "correct": true,  "explanation": null },
        { "option": "b", "text": "Es programada por el kernel del SO", "correct": true,  "explanation": null },
        { "option": "c", "text": "Viene con programación por defecto basado en el estandard de la IEEE", "correct": false, "explanation": "Se programa en arranque, no un estándar IEEE genérico." },
        { "option": "d", "text": "Ejecuta las ISR directamente sin intervención del CPU", "correct": false, "explanation": "Solo notifica a la CPU; no ejecuta código de ISR." }
      ]
    },
    {
      "id": 19,
      "question": "Si llega una nueva IRQ durante una ISR sin enmascarar, ¿qué ocurre?",
      "options": [
        { "option": "a", "text": "Se interrumpe la ISR actual para atender la nueva", "correct": true, "explanation": null },
        { "option": "b", "text": "Se termina la ISR actual y luego se atiende", "correct": false, "explanation": "Incorrecto" }
      ]
    },
    {
      "id": 20,
      "question": "El anidamiento de ISR ocurre cuando…",
      "options": [
        { "option": "a", "text": "Una ISR es interrumpida por otra de igual o mayor prioridad", "correct": true,  "explanation": null },
        { "option": "b", "text": "Las ISR se encolan en FIFO", "correct": false, "explanation": "No es un esquema FIFO." },
        { "option": "c", "text": "Varias interrupciones llegan simultáneamente al buffer de la PIC", "correct": false, "explanation": "El anidamiento requiere reentrada a ISR, no simplemente llegada múltiple." },
        { "option": "d", "text": "IRET no se ejecuta antes de atender la siguiente ISR", "correct": true, "explanation": null }
      ]
    },
    {
      "id": 21,
      "question": "¿Cuál es un riesgo del anidamiento ilimitado de ISR?",
      "options": [
        { "option": "a", "text": "Stack overflow", "correct": true,  "explanation": null },
        { "option": "b", "text": "Corrupción de datos", "correct": true,  "explanation": null },
        { "option": "c", "text": "Complejidad extrema en el flujo de ejecución", "correct": true,  "explanation": null },
        { "option": "d", "text": "Latencia impredecible en atención de interrupciones", "correct": true,  "explanation": "El nesting excesivo puede hacer que interrupciones críticas esperen demasiado." },
        { "option": "e", "text": "Reinicio automático de la PIC", "correct": false, "explanation": "No es un efecto del anidamiento; la PIC no se reinicia automáticamente." }
      ]
    },
    {
      "id": 22,
      "question": "La corrupción de datos en anidamiento ilimitado puede ocurrir porque…",
      "options": [
        { "option": "a", "text": "Dos ISR usan variables o dispositivos compartidos sin protección", "correct": true, "explanation": null },
        { "option": "b", "text": "La CPU ejecuta varias ISR en paralelo", "correct": false, "explanation": "Se interrumpen en serie, no paralelo." }
      ]
    },
    {
      "id": 23,
      "question": "El stack overflow en anidamiento ilimitado ocurre porque…",
      "options": [
        { "option": "a", "text": "Cada nueva ISR reserva espacio en la pila", "correct": true, "explanation": null },
        { "option": "b", "text": "La ISR sobrescribe la pila del usuario", "correct": false, "explanation": "Cada ISR añade marco de pila, no sobrescribe uno existente." }
      ]
    },
    {
      "id": 24,
      "question": "Para enmascarar interrupciones puede combinarse:",
      "options": [
        { "option": "a", "text": "Modificar IMR en la PIC", "correct": true, "explanation": null },
        { "option": "b", "text": "Bajar el bit IF en EFLAGS/RFLAGS", "correct": true, "explanation": null },
        { "option": "c", "text": "Combinación de A y B", "correct": true, "explanation": null },
        { "option": "d", "text": "Ninguna de las anteriores", "correct": false, "explanation": "Cualquiera de las anteriores opciones es valida" }
      ]
    },
    {
      "id": 25,
      "question": "El clock de interrupciones… (seleccione todas las correctas)",
      "options": [
        { "option": "a", "text": "Es un dispositivo de hardware", "correct": true,  "explanation": null },
        { "option": "b", "text": "Es un reloj conceptual parte del SO", "correct": false, "explanation": "Es hardware, no solo conceptual." },
        { "option": "c", "text": "Se programa a través del APIC local", "correct": false, "explanation": "La programación la controla el kernel, no es inherente al clock de interrupciones." },
        { "option": "d", "text": "Genera interrupciones periódicas", "correct": true,  "explanation": null },
        { "option": "e", "text": "Es lo único que garantiza que el SO se active periódicamente", "correct": true,  "explanation": null },
        { "option": "f", "text": "Sincroniza las etapas del pipeline de la CPU", "correct": false, "explanation": "Eso corresponde al reloj interno de la CPU, no al clock de interrupciones." }
      ]
    },
    {
      "id": 26,
      "question": "La interrupción de reloj también se conoce como…",
      "options": [
        { "option": "a", "text": "IRQ0", "correct": true, "explanation": null },
        { "option": "b", "text": "Tick", "correct": true, "explanation": null },
        { "option": "c", "text": "Clock interrupt", "correct": true, "explanation": null },
        { "option": "d", "text": "Timer interrupt", "correct": true, "explanation": null }
      ]
    },
    {
      "id": 27,
      "question": "Sin el clock de interrupciones, ¿un proceso de usuario podría apropiarse de la CPU?",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": true, "explanation": null },
        { "option": "b", "text": "Falso", "correct": false, "explanation": null }
      ]
    },
    {
      "id": 28,
      "question": "La interrupción de clock se trata como cualquier otra interrupción",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": true, "explanation": null },
        { "option": "b", "text": "Falso", "correct": false, "explanation": "Incorrecto" }
      ]
    },
    {
      "id": 29,
      "question": "Funciones típicas de la ISR del clock incluyen…",
      "options": [
        { "option": "a", "text": "Actualizar el reloj del sistema", "correct": true, "explanation": null },
        { "option": "b", "text": "Aumentar el contador de tiempo del proceso actual", "correct": true, "explanation": null },
        { "option": "c", "text": "Decidir si es momento de un cambio de contexto (scheduler)", "correct": true, "explanation": null }
      ]
    },
    {
      "id": 29,
      "question": "Funciones típicas de la ISR del clock incluyen…",
      "options": [
        { "option": "a", "text": "Actualizar el reloj del sistema", "correct": true,  "explanation": null },
        { "option": "b", "text": "Aumentar el contador de tiempo del proceso actual", "correct": true,  "explanation": null },
        { "option": "c", "text": "Sincronizar la frecuencia de la CPU con el reloj de interrupciones", "correct": false, "explanation": "La frecuencia de la CPU es independiente del timer de interrupciones." },
        { "option": "d", "text": "Decidir si es momento de un cambio de contexto (scheduler)", "correct": true,  "explanation": null },
        { "option": "e", "text": "Registrar estadísticas de uso de memoria", "correct": false, "explanation": "Eso suele hacerlo el gestor de memoria, no la ISR del clock." }
      ]
    },
    {
      "id": 30,
      "question": "¿El reloj de interrupciones es también llamado reloj de la CPU?",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": false, "explanation": "El reloj de la CPU es un dispositivo de hardware diferente, que indica la frecuencia del procesador determinando las MIPS" },
        { "option": "b", "text": "Falso", "correct": true, "explanation": null }
      ]
    },
    {
      "id": 30,
      "question": "IRET es",
      "options": [
        { "option": "a", "text": "Una rutina", "correct": false, "explanation": "Incorrecto" },
        { "option": "b", "text": "Una instrucción", "correct": true, "explanation": null }
      ]
    },
    {
      "id": 31,
      "question": "La PIC es responsable de",
      "options": [
        { "option": "a", "text": "Organizar llamadas al sistema", "correct": false, "explanation": "Incorrecto" },
        { "option": "b", "text": "Gestionar interrupciones externas generadas por controladoras", "correct": true, "explanation": null },
        { "option": "c", "text": "Gestionar interrupciones en modo no privilegiado", "correct": false, "explanation": "Incorrecto" }
      ]
    },
    {
      "id": 32,
      "question": "Las interrupciones son generadas exclusivamente por las controladoras",
      "options": [
        { "option": "a", "text": "Verdadero", "correct": true, "explanation": null },
        { "option": "b", "text": "Falso", "correct": false, "explanation": "Incorrecto, la CPU tambien puede generar interrupciones a nivel interno pero estas se denominan excepciones" }
      ]
    }
  ]
}
